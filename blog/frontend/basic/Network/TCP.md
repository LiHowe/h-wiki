---
WIP: true
---



# TCP/IP基础

## 网络基础

一个通信通过

+ 源IP地址
+ 目标IP地址
+ 协议号
+ 源端口号
+ 目标端口号

这五个元素来识别与区分

### 数据包

+ `包`: 全能性术语
+ `帧`: 数据链路层中`包`的单位
+ `数据包`: IP和UDP等网络层以上分层中`包`的单位
+ `段`: TCP数据流中的信息
+ `消息`: 应用协议中数据的单位



`MAC地址`: 用来识别同一链路中不同的计算机, 相当于计算机在网络中的ID

`IP地址`: 用来识别TCP/IP网络中互联的主机和路由器

`端口号(程序地址)`: 在传输层, 用于识别同一台计算机中进行通信的不同程序



网络中传输的数据包由两部分组成

1. 该层协议所要用到的头部信息
2. **上一层**传过来的数据

以用户A向用户B发送消息为例

![邮件发送流程](https://i.loli.net/2021/11/23/asnAw6Et2YQycPV.png)

## TCP & UDP

`TCP`与`UDP`是传输层代表性的协议



### TCP三次握手

<img src="https://i.loli.net/2021/11/24/FanYWjfBsGL6q2A.png" alt="Group 24" style="zoom:50%;" />



如果一定时间内没有等待到ACK(确认应答), 则认为数据丢失, 进行重发

第三次握手可以携带数据

> **Q: 两次握手可以吗?**
>
> A: 
>
> 1. 第二次握手之后服务器无法确认客户端的**接收**能力
> 2. 如果第二次握手的报文丢失, 那么客户端无法知晓服务端的初始序列号(seq), 就无法保证TCP的可靠性



### TCP四次挥手

<img src="https://i.loli.net/2021/11/24/RGxhswK89CvSj5Z.png" alt="Group 25" style="zoom:50%;" />



> **Q：为什么建立连接握手三次，关闭连接时需要是四次呢？**
>
> A: 
>
> 其实在 TCP 握手的时候，接收端发送 `SYN+ACK` 的包是将一个 `ACK` 和一个 `SYN` 合并到一个包中，所以减少了一次包的发送，三次完成握手。
>
> 对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 `FIN` 包与对客户端的 `ACK` 包合并发送，只能先确认 `ACK`，然后服务器待无需发送数据时再发送 `FIN` 包，所以四次挥手时必须是四次数据包的交互。

> **Q：为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态？**
>
> A:
>
> `MSL` 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 `FIN` 的确认包 `ACK` 后，这个 `ACK` 包是有可能不可达的，服务器端如果收不到 `ACK` 的话需要重新发送 `FIN` 包。
>
> 所以客户端发送 `ACK` 后需要留出 `2MSL` 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。
>
> 也就是说客户端如果等待 `2MSL` 时间也没有收到服务器端的重传包 `FIN`，说明可以确认服务器已经收到客户端发送的 `ACK`。
>
> 还有第 *2* 个理由，避免新旧连接混淆。
>
> 在客户端发送完最后一个 `ACK` 报文段后，在经过 `2MSL` 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文。
>
> 你要知道，有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。



### 状态编码及含义

| 编码           | 含义                                                         | 端   |
| -------------- | ------------------------------------------------------------ | ---- |
| `LISTEN`       | 服务器等待从任意远程TCP端口的连接请求。侦听状态。            | S    |
| `SYN-SENT`     | 客户在发送连接请求后等待匹配的连接请求。向服务器发出一个同步（SYNC）信号后进入此状态 | C    |
| `SYN-RECEIVED` | 服务器已经收到并发送同步（SYNC）信号之后等待确认（ACK）请求  | S    |
| `ESTABLISHED`  | 服务器与客户的连接已经打开，可以正常通信。此时连接两端是平等的。这称作**全连接** | S&C  |
| `FIN-WAIT-1`   | 服务端或客户端主动关闭, 发出FIN请求包，表示本方的数据发送全部结束，等待TCP连接另一端的ACK确认包或FIN&ACK请求包。 | S&C  |
| `FIN-WAIT-2`   | 主动关闭端在FIN-WAIT-1状态下收到ACK确认包，进入等待远程TCP的连接终止请求的**半关闭状态**。这时可以接收数据，但不再发送数据 | S&C  |
| `CLOSE-WAIT`   | 被动关闭端接到FIN后，就发出ACK以回应FIN请求，并进入等待本地用户的连接终止请求的**半关闭状态**。这时可以发送数据，但不再接收数据 | S&C  |
| `LAST-ACK`     | 被动关闭端全部数据发送完成之后，向主动关闭端发送FIN，进入等待确认包的状态 | S&C  |
| `TIME-WAIT`    | 主动关闭端接收到FIN后，就发送ACK包，等待足够时间以确保被动关闭端收到了终止请求的确认包。（一个连接可以在TIME-WAIT保证最大四分钟, 即2倍最大分段寿命(2MSL) | S/C  |
| `CLOSED`       | 完全没有连接                                                 | S&C  |



### ISN

`ISN` 全称是 `Initial Sequence Number`，是 TCP 发送方的字节数据编号的原点，告诉对方我要开始发送数据的初始化序列号

ISN 是动态生成的, 因为ISN 如果是固定的，攻击者很容易猜出后续的确认序号，为了安全起见，避免被第三方猜到从而发送伪造的 `RST` 报文



### 半连接队列 & 全连接队列

半连接队列: 服务器第一次收到客户端的 `SYN` 之后，就会处于 `SYN_RCVD` 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。

全连接队列: 客户端与服务器完成三次握手之后建立的连接会放入全连接队列



## IP

### IP结构

IP位于OSI分层的网络层, 主要分为三大功能模块

1. IP寻址
2. 路由
3. IP分包与组包



IP地址是由32位正整数, 每8位为一组, 每组以`.`隔开, 最后将每组转为10进制表示

比如

`172.20.1.1` 代表 `10101100000101000000000100000001`



### 子网掩码

